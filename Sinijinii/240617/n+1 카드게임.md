# n+1 카드게임
---
## 풀이 방법
 - 처음에는 문제를 잘못 읽어서 카드를 가지고 오기 or 2장 내기인줄 알고 삽질했다^^
 - 그 후 다시 시도한 방법
 - 2장을 뽑은 후 다 버리기, 1장 선택, 2장 다가져오기 방법을 나눠서 진행해보았다.
 - 문제의 흐름대로 코드를 작성했다고 생각했으나.. 실패다..
 - 내가 놓친 부분이 있는지 다시 확인할 것이다.

## 코드
---
```python
from itertools import combinations

def f(coin, my_cards, remain_cards, round_count, tar):
    global max_cnt

    # 남은 카드가 없을 경우
    if not remain_cards:
        max_cnt = max(max_cnt, round_count)
        return

    # 각 라운드의 시작에서 두 장의 카드를 뽑기
    if len(remain_cards) >= 2:
        card1, card2 = remain_cards[0], remain_cards[1]
        remain_cards = remain_cards[2:]

        # 4경우
        # 1. 두 장 다 버리기
        f(coin, my_cards, remain_cards, round_count, tar)

        # 2. card1 가져오기
        if coin >= 1:
            f(coin - 1, my_cards + [card1], remain_cards, round_count, tar)

        # 3. card2 가져오기
        if coin >= 1:
            f(coin - 1, my_cards + [card2], remain_cards, round_count, tar)

        # 4. 두 장 다 가져오기
        if coin >= 2:
            f(coin - 2, my_cards + [card1, card2], remain_cards, round_count, tar)

            
        # 카드 제출 확인하기
        submt = False
        for comb in combinations(my_cards, 2):
            if sum(comb) == tar:
                updated_my_cards = my_cards[:]
                updated_my_cards.remove(comb[0])
                updated_my_cards.remove(comb[1])
                submt = True
                f(coin, updated_my_cards, remain_cards, round_count + 1, tar)
                # 제출했으니 종료?
                break
                
        # 제출하지 못할경우 
        if not submt:
            max_cnt = max(max_cnt, round_count)
            return

        
def solution(coin, cards):
    global max_cnt
    # 최종 값
    max_cnt = 0
    card_len = len(cards)
    tar = card_len + 1
    n = card_len // 3
    first_my_cards = cards[:n]
    remain_cards = cards[n:]
    
    f(coin, first_my_cards, remain_cards, 0, tar)
    
    return max_cnt

```

**뭐가 문제일까..**