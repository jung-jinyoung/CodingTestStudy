# [단어 퍼즐](https://school.programmers.co.kr/learn/courses/30/lessons/12983)

프로그래머스 Lv.4

## 문제

최소 단어조각 개수로 주어진 문장을 완성해라

최소 단어조각 개수를 return 해라. 불가능하면 -1 return 해라

## 풀이

t = "apple"이고 <br>
strs = ["app","ap","p","l","e","ple","pp"]이라면

`a`를 만들 방법은 1가지

1. <del>`a`를 사용 -> 하지만 strs에 없음 -> 불가능</del>

`ap`를 만드는 방법은 2가지

1. <del>`a` + `p` -> `a`가 없음 -> 불가능</del>
2. `ap` 사용 -> 가능 -> 1번만에 가능

`app`을 만드는 방법은 3가지

1. +`app` -> 1번에 가능
2. <del>a + `pp` -> a를 만들수 없으므로 불가능
3. ap + `p` -> ap를 만들 수 있으므로 2번만에 가능

다음으로 `appl`을 만드는 방법은 4가지

1. `appl` 사용 -> strs에 없음 -> 불가능
2. <del> `a` + `ppl` -> `a`를 못만듦 -> 불가능
3. <del>`ap` + `pl` -> `ap`를 한번만에 만들수있고 `pl`이 없음 -> 불가능
4. `app` + `l` -> `app`를 한번만에 만들 수 있고 `l`이 strs에 잇음 -> 2번만에 가능

이런 방법을 이용해서 apple을 만들 수 있음

모든 단어 조각의 길이가 1이상 5이하이므로 최대 5\*20,000 => 10만 반복이므로 위의 방법을 적용해서 풀 수 있음

위 방법대로 dp를 적용해서 문제를 풀거임

## 코드

100/100

```python
def solution(strs, t):
    N = len(t) #문자열 길이 재기
    dp = [N+1 for _ in range(N+1)] #(최댓값 + 1)로 모두 넣어줌
    dp[0] = 0 #아무것도 없는 부분이고 사용한 단어조각 없으므로 0으로 초기화

    for i in range(1,N+1): # i는 단어의 끝부분 위치
        for d in range(5,0,-1): #문자열의 길이는 "1~5"지만 무언가 거꾸로 하고 싶어서 "5~1"로 바꿔줌
            if i-d >=0: #인덱스에러가 안날 경우
                if t[i-d: i] in strs:#자른 문자열이 strs에 있는 경우
                    dp[i] = min(dp[i], dp[i-d] + 1) #둘 중 작은 것 선택하기

    if dp[-1] == N+1: #만약 단어가 완성되지 않은 경우
        return -1

    return dp[-1] #최소 단어 조각 출력
```
