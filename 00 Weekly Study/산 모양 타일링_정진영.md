# 산 모양 타일링 
> (2024 카카오 인턴 기출) / 프로그래머스    

### 목표
1. `도형 + DP 복합 유형의 문제`의 접근 방법 및 분석 방법을 익힌다.
2. `DP`를 `2차원 리스트`로 작성하고 활용한다

### 풀이
1. 오른쪽으로 합쳐지기 때문에, 합쳐지기 전 경우의 수를 분석한다. 
2. 분석한 경우의 수로 DP 다차원 리스트를 작성한다. 이 문제의 경우 2가지이다.
    1. 오른쪽 모서리 마름모꼴로 채울 경우
    2. 채우지 않을 경우
3. 다음으로 위에 정삼각형이 올라올 경우의 수를 생각한다.
    1. tops[i] 가 있을 경우
    2. tops[i] 가 없을 경우
    
## CODE (Python)
```python 
def solution(n, tops):
    mod = 10007
    dp = [[0, 0] for _ in range(n + 1)]

    dp[1][0] = 1
    if tops[0] == 0:
        dp[1][1] = 2
    else:
        dp[1][1] = 3

    # 인덱스를 위한 더미 생성
    tops = [0] + tops
    for idx in range(2, n + 1):

        # 오른쪽 모서리 마름모 채울 경우의 수
        dp[idx][0] = sum(dp[idx - 1]) % mod  # 모든 경우의 수 더하기

        # 채우지 않을 경우의 수
        if tops[idx] == 0:
            dp[idx][1] = (dp[idx - 1][0] + 2 * dp[idx - 1][1]) % mod
        elif tops[idx] == 1:
            dp[idx][1] = (2 * dp[idx - 1][0] + 3 * dp[idx - 1][1]) % mod

    answer = sum(dp[n]) % 10007
    return answer
```

<br><br>

## REVIEW
1. 규칙을 찾는 것이 정말 어려웠다. 3시간 동안 그림을 그리면서 찾은 규칙이 맞지 않아서 정답 코드들을 찾아 분석하였다.
2. 규칙을 이해하고 코드를 작성 후 제출했는데 24번째 테스트케이스에서 시간 초과가 발생했다.<br>
    해당 문제의 경우 10007를 나눈 나머지를 구하는 것인데, 처음에는 dp[n] % 10007로 return 했더니, 시간 초과가 발생했다.
3. `숫자가 클 수록 연산 시간이 오래 걸리기 때문에` 발생한 `시간초과` 문제이다.  따라서 DP에 저장되는 값이 연산된 값을 10007로 나눈 나머지가 되도록 수정했다. 
4. 도형 관련 DP 문제를 SWEA 와 백준에서 이전에 기초 문제를 풀어봤는데, 조금 다른 규칙을 만나서 당황했었던 것 같다. (내가 도형에 약하다는 걸 다시 깨달았다 ㅠ)