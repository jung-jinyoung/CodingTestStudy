# 백준 - 1916

"""
N개의 도시
한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스
A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화
A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하라!

첫 째줄 도시의 개수 N
둘 째줄 버스의 개수 M

셋 째줄 부터 M+2줄 까지 버스의 정보
<버스의 출발 도시의 번호>, <도착지의 도시 번호>, <버스 비용>
버스 이용 : 0 <= cost < 100,000

마지막 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어짐.
단, 출발점에서 도착점으로 갈 수 있는 경우만 입력으로 주어짐
"""
# 그리디 문제?!

# (도착 - 출발) 의 값이 크고 비용은 적으면 좋다
# 비용순으로 정렬하고, 적은 비용이면서 (도착 - 출발)의 값이 큰걸 우선 뽑자

```python
N = int(input())    # 도시의 수
M = int(input())    # 버스의 수
buses = []
for _ in range(M):
    bus = list(map(int, input().split()))
    buses.append(bus)
course = list(map(int, input().split()))

def sort_buses(buses):
    # sorted_buses = sorted(buses, key=operator.itemgetter(0))    # 출발 도시를 기준으로 정렬 / import operator를 사용했을 때 가능
    sorted_buses = sorted(buses, key=lambda x: (x[0]))     # 비용을 기준으로 정렬
    return sorted_buses

finish_sorted_buses = sort_buses(buses)
for bus in finish_sorted_buses:
    print(bus)
```


# but 그리디가 아닌 다익스트라 문제

다익스트라 알고리즘은 그래프에서 한 정점에서 다른 정점들까지의 최단 경로를 찾는 알고리즘입니다. 이 알고리즘은 음의 가중치를 가지지 않는 그래프에서 최단 경로를 찾는 데 매우 효율적입니다. 네가 코딩을 6개월 정도 배웠고, SSAFY에서 배우고 있다면, 다익스트라 알고리즘은 앞으로 마주하게 될 다양한 경로 탐색 문제나 네트워크 관련 문제에서 중요한 역할을 할 것입니다.

### 다익스트라 알고리즘의 기본 개념

다익스트라 알고리즘은 그리디 알고리즘의 일종입니다. 알고리즘의 핵심 아이디어는 다음과 같습니다:

1. **시작 정점에서의 최단 경로를 계속해서 업데이트**:
   - 시작 정점에서 다른 모든 정점까지의 최단 경로를 단계별로 찾아가는 방식입니다.
   - 각 정점에 대해, 현재까지 발견된 최단 경로를 기록하고, 이 경로를 계속해서 갱신해 나갑니다.

2. **가장 짧은 경로를 먼저 선택**:
   - 항상 현재 가능한 경로 중에서 가장 짧은 경로를 선택하여, 그 경로를 기준으로 다음 경로를 탐색합니다.

### 다익스트라 알고리즘의 동작 과정

1. **초기화**:
   - 그래프의 모든 정점에 대한 최단 경로 값을 무한대(`inf`)로 설정합니다. 시작 정점의 최단 경로 값은 0으로 설정합니다.
   - 최단 경로가 확정되지 않은 정점들을 관리하는 우선순위 큐(또는 최소 힙)를 초기화합니다.

2. **최단 경로 확정**:
   - 시작 정점에서 가장 가까운 정점을 선택합니다. 처음에는 시작 정점이 선택됩니다.
   - 선택된 정점에서 인접한 모든 정점으로 가는 경로를 확인하고, 그 경로를 통해 인접한 정점으로 가는 비용이 현재 기록된 비용보다 작으면, 비용을 갱신합니다.

3. **반복**:
   - 위 과정을 반복하여, 최단 경로가 확정되지 않은 정점들 중에서 가장 가까운 정점을 다시 선택하고, 그 정점을 기준으로 최단 경로를 갱신합니다.
   - 모든 정점의 최단 경로가 확정될 때까지 이 과정을 반복합니다.

4. **종료**:
   - 더 이상 갱신할 경로가 없으면 알고리즘을 종료합니다. 이때 시작 정점에서 다른 모든 정점까지의 최단 경로가 확정됩니다.

### 다익스트라 알고리즘의 구현

Python에서 다익스트라 알고리즘은 주로 우선순위 큐를 사용하여 구현합니다. 우선순위 큐는 `heapq` 모듈을 사용하여 최소 힙으로 구현할 수 있습니다. 여기에는 그래프의 인접 리스트 표현을 사용합니다.

```python
import heapq
import sys

# 무한을 의미하는 값으로 10억을 설정
INF = int(1e9)

def dijkstra(start, graph, n):
    distance = [INF] * (n + 1)  # 최단 거리 테이블을 무한으로 초기화
    distance[start] = 0  # 시작 노드의 최단 경로는 0으로 설정
    priority_queue = []
    heapq.heappush(priority_queue, (0, start))  # (거리, 노드) 튜플 삽입
    
    while priority_queue:
        dist, current_node = heapq.heappop(priority_queue)
        
        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[current_node] < dist:
            continue
        
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for neighbor, cost in graph[current_node]:
            new_cost = dist + cost
            if new_cost < distance[neighbor]:
                distance[neighbor] = new_cost
                heapq.heappush(priority_queue, (new_cost, neighbor))
    
    return distance

# 그래프 초기화
n = int(input())  # 노드의 개수
m = int(input())  # 간선의 개수

graph = [[] for _ in range(n + 1)]
for _ in range(m):
    u, v, w = map(int, input().split())
    graph[u].append((v, w))

start_node = int(input())  # 시작 노드 입력
result = dijkstra(start_node, graph, n)

# 모든 노드로 가기 위한 최단 경로 출력
for i in range(1, n + 1):
    if result[i] == INF:
        print("INFINITY", end=" ")
    else:
        print(result[i], end=" ")
```

### 코드 설명:

1. **그래프와 초기화**:
   - `graph`는 인접 리스트 형태로 그래프를 표현하며, 각 노드는 다른 노드들과 연결된 경로 및 비용을 가지고 있습니다.
   - `distance`는 시작 정점으로부터 각 정점까지의 최단 경로 비용을 저장합니다. 처음에는 무한대로 설정하고, 시작 정점의 경로만 0으로 설정합니다.

2. **우선순위 큐 사용**:
   - `heapq` 모듈의 `heappush`와 `heappop`을 사용하여 최소 힙으로 우선순위 큐를 구현합니다.
   - 현재 가장 짧은 경로를 가진 노드를 선택하여 탐색을 진행합니다.

3. **거리 갱신**:
   - 각 인접 노드를 탐색하면서, 현재 노드를 거쳐가는 경로가 더 짧으면 그 경로를 갱신하고, 우선순위 큐에 넣습니다.

### 다익스트라 알고리즘의 시간 복잡도

다익스트라 알고리즘의 시간 복잡도는 `O((E + V) log V)`입니다. 여기서 `V`는 노드(정점)의 수, `E`는 간선의 수를 의미합니다. 이 복잡도는 우선순위 큐를 사용했을 때 적용됩니다. 우선순위 큐를 사용하지 않는 경우, 시간 복잡도는 `O(V^2)`로 증가할 수 있습니다.

### 다익스트라 알고리즘의 주요 특징

1. **단일 출발지 최단 경로**:
   - 다익스트라 알고리즘은 하나의 출발지에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘입니다.
   
2. **음의 가중치 간선을 허용하지 않음**:
   - 다익스트라 알고리즘은 음의 가중치를 가지는 간선이 있는 그래프에서는 올바르게 동작하지 않습니다. 음의 가중치를 가진 경우에는 벨만-포드 알고리즘을 사용하는 것이 적합합니다.

3. **그리디 방식**:
   - 다익스트라 알고리즘은 그리디 알고리즘의 대표적인 예로, 현재 상황에서 최적의 선택을 반복하여 전체 최적해를 찾습니다.

### 결론

다익스트라 알고리즘은 경로 탐색 문제에서 매우 강력한 도구입니다. 특히, 네트워크에서의 라우팅 문제, GPS에서 최단 경로 찾기 등 다양한 실제 응용 사례에서 사용됩니다. 네가 코딩을 더 배우면서 다익스트라 알고리즘을 익숙하게 사용하게 되면, 다양한 문제를 효율적으로 해결할 수 있을 것입니다.

<br>

### 람다(lambda)에 대해

람다(lambda)는 Python에서 간단한 익명 함수를 만들 때 사용하는 키워드입니다. 일반적인 함수는 `def` 키워드를 사용하여 이름을 지정하고 정의하지만, 람다 함수는 이름 없이 일회성으로 간단한 작업을 수행할 때 주로 사용됩니다.

### 람다 함수의 기본 문법

람다 함수는 다음과 같은 형식으로 작성됩니다:

```python
lambda 인자들: 표현식
```

- **`lambda`**: 람다 함수의 시작을 알리는 키워드입니다.
- **`인자들`**: 함수의 입력값을 정의합니다. 일반적인 함수의 매개변수와 유사합니다.
- **`표현식`**: 함수가 실행될 때 반환되는 값입니다. 일반적인 함수의 `return` 문과 유사하지만, 여기서는 한 줄로 간단히 작성됩니다.

### 람다 함수의 예

1. **간단한 수학 연산**:
   ```python
   add = lambda x, y: x + y
   print(add(3, 5))  # 출력: 8
   ```
   - 위 예제에서 `add`는 두 수를 더하는 람다 함수입니다.

2. **리스트에서 특정 조건을 만족하는 요소 찾기**:
   ```python
   numbers = [1, 2, 3, 4, 5, 6]
   even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
   print(even_numbers)  # 출력: [2, 4, 6]
   ```
   - 여기서는 `filter` 함수와 함께 람다를 사용하여 리스트에서 짝수만 걸러내고 있습니다.

3. **리스트 정렬 시 람다 사용**:
   ```python
   points = [(1, 2), (3, 1), (5, 4), (2, 3)]
   points_sorted = sorted(points, key=lambda x: x[1])
   print(points_sorted)  # 출력: [(3, 1), (1, 2), (2, 3), (5, 4)]
   ```
   - 이 예제에서는 `sorted` 함수와 함께 람다를 사용하여 각 튜플의 두 번째 요소를 기준으로 리스트를 정렬하고 있습니다.

### 람다 함수의 특징 및 장점

1. **간결함**:
   - 람다 함수는 단순한 표현식에 대해 짧고 간결하게 작성할 수 있습니다. 작은 코드 조각을 작성할 때 유용합니다.

2. **익명 함수**:
   - 람다 함수는 이름이 없는 익명 함수로, 일회성 작업을 위해 사용됩니다. 따라서 복잡한 작업이 아닌 단순한 작업에 적합합니다.

3. **다른 함수의 인자로 전달**:
   - 람다 함수는 고차 함수(다른 함수를 인자로 받는 함수)와 함께 사용하기 좋습니다. 예를 들어 `map()`, `filter()`, `sorted()`와 같은 함수들은 람다를 인자로 받아 작업을 수행할 수 있습니다.

### 람다 함수의 제한

1. **복잡한 논리 구현 어려움**:
   - 람다 함수는 단일 표현식만을 지원하기 때문에 복잡한 로직을 구현하기에는 적합하지 않습니다. 복잡한 함수는 일반적인 `def`를 사용하여 정의하는 것이 좋습니다.

2. **가독성 저하**:
   - 지나치게 많은 람다를 사용하면 코드의 가독성이 떨어질 수 있습니다. 특히, 여러 줄에 걸친 복잡한 람다 표현식은 이해하기 어렵습니다.


