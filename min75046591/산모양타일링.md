## 산모양 스타일링

### 풀이법
참고 페이지
https://tolerblanc.github.io/programmers/programmers-mountain-tiling/
> dp로 접근  
> top에 삼각형이 있는 경우와 없는 경우를 분리  
> 
> 점화식 도출  
> dp1[i] = dp1[i - 1] + dp2[i - 1]  
> dp2[i] = dp1[i - 1] * (1 or 2) + dp2[i - 1] * (2 or 3)

1. 상수 설정:
MOD = 10007 : 결과를 10007로 나눈 나머지를 구하기 위해 사용.

<br>

2. 동적 배열 초기화:
dp1 : 정삼각형 타일로 채우는 경우의 수를 저장하는 배열.
dp2 : 마름모 타일로 채우는 경우의 수를 저장하는 배열.

<br>

3. 초기 상태 설정:
dp1[0] = 1 : 첫 위치는 정삼각형 하나로 채울 수 있다.
dp2[0] = 2 + tops[0] : 첫 위치는 tops[0]에 따라 정삼각형 또는 마름모로 채울 수 있음.

<br>

4. 동적 계획법을 통한 경우의 수 계산:
dp1[i] : i번째 위치까지의 정삼각형과 마름모로 채운 경우의 수의 합.
dp2[i] : 현재 위치에 정삼각형을 붙일 수 있는 경우와 붙이지 않는 경우로 나누어 계산.

<br>

5. 최종 결과 반환:
dp1과 dp2의 마지막 원소를 더한 후 MOD로 나눈 나머지를 반환.

### code

```python
def solution(n, tops):
    MOD = 10007  # 결과를 10007로 나눈 나머지를 구하기 위한 상수

    # dp1[i]는 i번째 위치까지 사다리꼴 모양을 정삼각형 타일로 채우는 경우의 수
    dp1 = [0] * n

    # dp2[i]는 i번째 위치까지 사다리꼴 모양을 마름모 타일로 채우는 경우의 수
    dp2 = [0] * n

    # 초기 상태 설정
    dp1[0] = 1  # 첫 위치는 정삼각형 하나로 채울 수 있음
    dp2[0] = 2 + tops[0]  # 첫 위치는 tops[0]에 따라 정삼각형 또는 마름모로 채울 수 있음

    # 각 위치에서 가능한 경우의 수를 누적하여 계산
    for i in range(1, n):
        # dp1[i]는 이전 위치까지의 정삼각형과 마름모로 채운 경우의 수의 합
        dp1[i] = (dp1[i - 1] + dp2[i - 1]) % MOD

        # dp2[i]는 현재 위치에 정삼각형을 붙일 수 있는 경우와 붙이지 않는 경우로 나눠서 계산
        dp2[i] = ((dp1[i - 1] * (1 + tops[i])) + (dp2[i - 1] * (2 + tops[i]))) % MOD

    # 최종 결과는 마지막 위치까지의 정삼각형과 마름모로 채운 경우의 수의 합
    return (dp1[-1] + dp2[-1]) % MOD
```