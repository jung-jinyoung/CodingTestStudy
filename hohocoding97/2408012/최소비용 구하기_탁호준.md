# [최소비용 구하기](https://www.acmicpc.net/problem/1916)

난이도 : 골드 5

## 문제

N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라.

## 개념

### 다익스트라

한 정점에서 다른 정점으로 가는 최단경로를 구하는 알고리즘

이 때, 음의 간선은 포함할 수 없음

다익스트라 알고리즘은 dp임. 왜냐면 `최단거리는 여러 개의 최단거리로 이루어져 있기 때문`

하나의 최단 거리를 구할 때, 이전까지의 최단 거리 정보를 그대로 사용함.

### 코드

```python
import sys
import heapq
from collections import defaultdict
input = sys.stdin.readline

N = int(input())            #도시 개수 -> 노드의 수
M = int(input())            #버스 개수 -> 간선의 수
graph = {i: {} for i in range(1, N+1)}    #그래프를 인접리스트로 표현(딕셔너리 of 딕셔너리)
INF = float("inf")          #무한대 값
for _ in range(M):
    start, end, cost = map(int, input().split()) # 출발 도시, 도착 도시, 가격
        # 같은 경로의 버스가 여러 개 있을 수 있으므로, 최소 비용만 저장
    if end in graph[start]:
        graph[start][end] = min(graph[start][end], cost)
    else:
        graph[start][end] = cost

# 출발지와 도착지 입력
start, end = map(int, input().split())

def dijkstra(graph, start, end):
    distances = {node: INF for node in graph}
    distances[start] = 0 #시작점에서 시작점으로 가는데 드는 비용

    # 우선순위 큐 초기화
    queue = [(0, start)]
    # 큐가 남아있으면 계속 반복
    while queue:
    # 가장 최단 거리가 짧은 노드 선택
        current_distance, current_node = heapq.heappop(queue)

        # 현재 노드가 이미 처리된 노드라면 무시
        if current_distance > distances[current_node]:
            continue

        # 목적지에 도착했다면 최단 거리 반환
        if current_node == end:
            return current_distance

        # 현재 노드와 연결된 인접 노드들 확인
        for adjacent, weight in graph[current_node].items():
            distance = current_distance + weight

            # 현재 노드를 거쳐 가는 거리가 더 짧은 경우 갱신
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(queue, (distance, adjacent))

    # 도달할 수 없는 경우
    return float('inf')

# 최소 비용 계산 및 출력
result = dijkstra(graph, start, end)
print(result)
```
