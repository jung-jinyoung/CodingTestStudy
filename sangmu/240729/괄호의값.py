'''
4개의 기호 ‘(’, ‘)’, ‘[’, ‘]’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다.

한 쌍의 괄호로만 이루어진 ‘()’와 ‘[]’는 올바른 괄호열이다.
만일 X가 올바른 괄호열이면 ‘(X)’이나 ‘[X]’도 모두 올바른 괄호열이 된다.
X와 Y 모두 올바른 괄호열이라면 이들을 결합한 XY도 올바른 괄호열이 된다.
예를 들어 ‘(()[[]])’나 ‘(())[][]’ 는 올바른 괄호열이지만 ‘([)]’ 나 ‘(()()[]’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열 X에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(X)로 표시한다.

‘()’ 인 괄호열의 값은 2이다.
‘[]’ 인 괄호열의 값은 3이다.
‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다.
‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다.
올바른 괄호열 X와 Y가 결합된 XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다.
예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자. ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로 ‘(()[[]])’의 괄호값은 2×11=22 이다. 그리고 ‘([])’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다.

여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다.

입력
첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다.

출력
첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다.

예제 입력 1 
(()[[]])([])
예제 출력 1 
28
예제 입력 2 
[][]((])
예제 출력 2 
0
'''

'''
생각 정리 :
1. () = 2이고 [] = 3이다
2. ([]) = 2 * 3 이다
3. stack 방식으로 생각해보자. ( or [ 가 stack에 들어오면 result * 2
4. 단순하게 3번처럼 생각하면 ()()[] 처럼 들어오면 전체결과가 제곱식으로 된다.
5. 아니지 닫힌 괄호가 나와서 stack가 비면 최종 result에 값을 더해주는 식으로 생각
6. 그렇다면 ( or [가 stack에 있다는건 그 이후에 열린 괄호에 대응하는 닫힌 괄호가 나오지 않으면 더해주고 대응하는 괄호가 나오면 곱해준다
7. ((())) = 2 * 2 * 2, ([]()) = (3 + 2) * 2
8. ( [ ( [ ] ( ) ) ] ) 를 생각해보자. (3 + 2) * 2 * 3 * 2 처럼 결국 괄호 안에 있는 (3 + 2) 이 3과 2에 집중해야한다.
9. 겉껍질에 해당하는 ([()])는 3과 2에 2 * 3 * 2 를 곱해준 것을 더해주는 것이 이 문제의 전부
10. ( 을 만난다면 껍질이라는 변수에(초기값 = 1)에 2를 곱해주고 [ 를 만난다면 3을 곱해준다
11. 이 개념을 8에 대입하면 껍질의 강도가 12가 되고 12 * 3 + 12 * 2 라고 생각하면 된다.
12. 결국, 닫힌 괄호를 만나고 짝이 맞다면 나눠주고 최종 result에 더해주면 된다
13. 풀이해보면, 2 * 3 * 2 * 3 이후 ] 가 짝에맞는 닫힌 괄호니까 result에 이 숫자를 더해준 후 3을 다시 나눠준다.
14. 그러면 2 * 3 * 2 는 유지되고 2를 다시 곱하고 짝에 맞는 닫힌 괄호가 다시 나오니까 result에 이 숫자를 더해준 후 2를 나눠준다.
15. 그러면 껍질에 해당하는 2 * 3 * 2가 남고 계속 나눠주면 된다.
16. 적다보니까 이러면 값이 필요 이상으로 커질 것 같다. 그 이유는 내가 알맹이야! 라는 정보는 얘는 모르기 때문이다
17. 알맹이라는 정보를 알려면 내가 stack에 넣은 닫힌 괄호 바로 이전 괄호가 맞는 괄호라면 더하고 바로 이전 괄호가 아니고 멀리 떨어진 괄호라면 나누기만 하면 될 것 같다.
18. 그리고 ([)] 같은 성립 안되는 것이 나오면 break !
'''

bracket = input()   # 괄호는 영어로 bracket
stack = []   # 열린 괄호를 넣어줄 stack array. if 닫힌 괄호가 들어오면 .pop()을 해줄 예정
result = 0   # 최종 결과값
shell = 1   # 초기 겉껍질의 강도 = 1

for i in range(len(bracket)):
    if bracket[i] == '(':
        shell = shell * 2   # 열린 괄호 ( 가 들어오면 겉껍질의 강도를 2 곱해준다
        stack.append(bracket[i])
    
    elif bracket[i] == '[':
        shell = shell * 3   # 열린 괄호 [ 가 들어오면 겉껍질의 강도를 3 곱해준다
        stack.append(bracket[i])

    
    elif bracket[i] == ')':
        # 닫힌 괄호에서는 append해주지 않고 pop만 실행해줄예정. 쓸데없는 행동 반복
        # 여기서 18번 step에 해당하는 성립 안되는 경우 : ) 가 단독으로 들어올 때, 이전에 들어왔던 괄호의 모양이 다를 때
        if not stack or stack[-1] == '[':
            result = 0
            break   # 스택이 비어있어서 단독으로 닫힌 괄호가 들어오거나, 괄호의 모양이 다르면 오류이므로 결과값에 0을 부여하고 for문 종료
        if bracket[i-1] == '(':
            result += shell   # 예외 처리를 마친 경우, 결과값에 shell강도에 알맹이 값을 곱한 값을 더해준다
        stack.pop()
        shell = shell // 2
        
    elif bracket[i] == ']':
        if not stack or stack[-1] == '(':
            result = 0
            break
        if bracket[i-1] == '[':
            result += shell
        stack.pop() 
        shell = shell // 3

if stack:
    print(0)
else:
    print(result)


    
    
